*************************************************
*******                                   *******
*******             KWHeap v3.1           *******
*******                                   *******
*************************************************

*******   Куча, на основе связанного списка,
*******   размер кучи - динамически увеличивающийся,
*******   однопоточная.

*******   В этой версии перемещена .Size, а также она не округляется -
*******   - для использования со строками PaString

SIZE0 - начальный размер
SIZESTEP - шаг увеличения размера кучи
эти константы должны быть округлены до размера страницы памяти

BLOCKBRICK - значение, до которого округляется размер блока памяти
            (при слиянии свободных блоков не учитывается)
MINBLOCKSIZE - минимальный размер блока памяти
INFOSIZE - размер служебной части в блоке памяти

все размеры и адреса округлены до dword как минимум,
кроме .Size

Куча:
(состоит из областей памяти)
------------------
| Область памяти |
------------------
        ...
------------------  <= дескриптор/хэндл кучи
| Область памяти |
------------------
        ...
        ...
Хэндл кучи указывает на первый байт первичной области памяти кучи.
Каждая область может находиться в произвольном месте памяти. 
Куда её размещать - зависит от ОС.

Область памяти:
[размером в целое число страниц памяти]
[адрес первого байта кратен размеру страницы]
(состоит из блоков памяти без зазоров между ними)
===============
| Блок памяти |
|=============|
| Блок памяти |
|=============|
|     ...     |
===============

Блок памяти:
===============================
| размер данных / флаги       | .Size {служебная часть}
| адрес след. блока           | .Next {служебная часть}
| адрес предыдущего блока     | .Prev {служебная часть}
|-----------------------------|
|                             |  <= дескриптор/хэндл блока памяти
| данные пользователя         |
|                             |
===============================

.Size - размер в байтах для данных в блоке (!!!)
bit31 - флаг занятого блока.
.Size должен быть меньше 2^31

.Next - Адрес следующего блока.
.Next == NULL : признак последнего блока в области.
.Next == -1 : признак последнего блока кучи (-1=0FFFFFFFFh)
в .Next сохраняются адреса блоков
  а передаются адреса данных в этих блоках (т.е. +INFOSIZE)
  
.Prev - адрес предыдущeго блока.
    если равен NULL, то начальный блок

BLOCKISBUSY = 80 00 00 00h
;1000 0000 0000 0000_0000 0000 0000 0000b

условимся что BLOCKGRANULARITY можно задавать равным 4, 8, 12, 16...
Адрес_следующего_блока округляется до BLOCKGRANULARITY, поэтому
как минимум два младших бита свободны.
Младший бит (номер 0) - занятость блока памяти
Бит номер 1 - флаг последнего блока памяти в области памяти.
Если блок последний в области и адрес следующего блока равен нулю - 
то это самый последний блок в куче.


Создание кучи:
Создаётся (первичная в данном случае) область памяти размером SIZE0.
Хэндл кучи = адрес полученой памяти.

Создание области памяти:
У ОС запрашивается область памяти заданного размера.
Создаётся незанятый блок памяти в весь размер области.

Создание блока памяти:
Начиная с первичной области памяти (хэндл кучи в помощь)
находим незанятый блок памяти подходящего размера.
Меняем статус на занятый, корректируем размер
и если есть остаток в блоке памяти, то из него создаём новый незанятый.
Корректируем адреса следующих блоков.
У последнего в цепочке блока адрес следующего блока равен LASTBLOCK

Если BLOCKBRICK задавать равным INFOSIZE или меньше,
 то при создании новых блоков их размер данных будет кратен BLOCKBRICK.
 Например: если INFOSIZE = 8, то BLOCKBRICK = 4 или 8.
 Если BLOCKBRICK задаётся больше (16, 32..),
 то и INFOSIZE надо делать равным BLOCKBRICK.

Добавление новой области памяти происходит если
не нашёлся подходящий блок памяти при создании нового блока.
Размер области = размер блока округлённый до размера страницы,
но не меньше SIZESTEP

Удаление блока памяти:
Меняем статус на незанятый,
 если следующий блок не занятый и идет непосредственно после удаляемого,
 то объединить эти блоки.
Данные удалённого блока не обнуляются.

**********************************************
сделать проверку при создании новой области:
если новая область примыкает к последней старой области -
 - объединить их.

подумыть над заменой .Size на (.Next-.this)
или замена .Next на .this+.Size+INFOSIZE  ...

**********************************************
Cделать ? проверку на правильный hHeap ?