
SIZE_START; начальный размер блока памяти
SIZE_END_X2; до какого размера удваивать
SIZE_BLOCK = SIZE_END_X2; далее прибавлять этот
                        ; размер
HeapSize
HeapBegin

---------------------------------
объект: размер окр. до 2^BITGRAN

len in bytes, word
data


...
------------------------------------
; KW Replaceable / Resizeable Heap
=-----------------------------------
Изменяемая однопоточная куча:
----------------
Структура KWRHEAPINFO
  Битовое поле
  Данные
  Таблица адресов данных (стэк)
----------------
Клиент запрашивает память из кучи,
получает адрес указателя.
Работает через этот указатель. 
Если гарантировано отсутствие вызовов
функций кучи:
HeapPut 
HeapDel 
HeapDefrag, и др.
то можно пользвать адрес взятый из указателя
ранее и не считывать его заново.
Для данных, в DataBottom сохраняется
адрес незанятого пространства для стэка
с таблицей адресов.
Стэк заполняется до DataBottom, затем
надо сделать HeapDefrag, и если DataBottom
не уменьшилось, увеличить размер кучи.
При удалении объекта из кучи также обнуляется 
адрес в таблице, кот. можно использовать для
следующего объекта.
ОДНАКО
Таблицу адресов перемещать нельзя, поэтому она 
должна лежать в отдельном участке памяти, или быть
стэковой, но после увеличения кучи и перемещения 
её в др. место, можно использовать старую память
кучи для стэковой таблицы! При этом делаем
HeapBottom = HeapBegin и не меняем более.
Тут нужен флаг IsHeapReplaced.
Таблица имеет переменные:
HeapTableBottom 
HeapTableTop 


------------------------------------
; таблица адресов и размеров блоков
; поиск свободного блока
------------------------------------
Жуть
Задаться:
текущий адрес TecAddr равен началу данных
Просканировать таблицу и найти ближайший
больший адрес NextAddr
Если меж ними влазит нужный блок - гут
Иначе TecAddr = NextAddr + BlockSize
Вернуться к сканированию


------------------------------------
; хранение переменных Бэйсика
------------------------------------
Простой вариант:
VarTablePtr - где находится таблица
переменных.
Сама таблица:
VarTable[] - адреса данных для переменных 
VARIABLE - структура данных для переменной:
  Длина имени
  Имя
  Тип (размер данных)
  Данные
Таблицу VarTable[] сортировать по алфавиту 
Возможно, завершающим элементом должен 
быть NULL или -1
    ; получить адрес данных пер-ной номер X
    mov eax,[VarTableAddr]
    mov eax,[eax + X*4]
    ; в eax адрес структуры VARIABLE
--------------
Или посложнее-побыстрее:
VarTable[] состоит из
  NameFirst - первые 4 символа имени
  Addr - адрес её структуры с данными
Если имя короче 4х букв, то старший разряд 
будет = 0, незанятые разряды должны быть 
обнулены 
Или не первые буквы, а хэш
--------------
Или VarTable[] состоит из:
  NameAddr - адрес имени, в куче
  Type
union
  ValAddr dd ? - адрес данных
  Val     dq ? - или значение
ends

--------------
--------------
Неперемещаемая куча с изменяемым размером
--------------
Зарезервировать под бит.поле адресное
пространство размером, соответствующим
всей памяти.
Размер поля задать начальным.
Первую гранулу данных занять под адрес
следующего добавочного блока данных.
Если гранула меньше 4 байт для 32-бит
системы, или 8 байт для 64-бит системы,
то надо занять несколько первых ячеек.
В блоке данных являющимся последним
ссылка на следующий блок данных равна 0.

Таким образом, битовое поле будет расти
не прерывая своё адресное пространство,
а блоки данных будут добавляться по
произвольным адресам.
Блок данных можно будет удалить,
если в нем не будет данных.
Для этого надо изменить ссылку в предыдущем
блоке на адрес следующего блока.
Предварительно сохраняя адреса ссылок
при сканировании.

Размер добавочных блоков данных для 
простоты можно принять таким же, как 
размер начального блока.

А можно и делать переменным, с шагом
равным нач. размеру.
Тогда надо сохранять не только адрес 
следующего блока, но и его размер.

