*************************************************
*******                                   *******
*******             KWHeap v3.0           *******
*******                                   *******
*************************************************

*******   Куча, на основе связанного списка,
*******   размер кучи - динамически увеличивающийся,
*******   однопоточная.                               Нужна многопоточная !!!


SIZE0 - начальный размер*
SIZESTEP - шаг увеличения размера кучи*
* - эти константы должны быть округлены до размера страницы памяти

BLOCKBRICK - значение, до которого округляется размер блока памяти
            (при слиянии свободных блоков не учитывается)
MINBLOCKSIZE - минимальный размер блока памяти
INFOSIZE - размер служебной части в блоке памяти

все размеры и адреса округлены до dword как минимум.

Куча:
(состоит из областей памяти)
------------------
| Область памяти |
------------------
        ...
------------------  <= дескриптор/хэндл кучи
| Область памяти | (первичная)
------------------
        ...
------------------
| Область памяти |
------------------
        ...
//Хэндл кучи указывает на первый байт первичной области памяти кучи.
Хэндл кучи - это адрес данных первичного блока -
 - дескриптор/хэндл первичного блока памяти
 (при создании кучи создаётся первичная область памяти,
  а в ней - первичный блок).
Все адреса, которые выдают "наружу" функции кучи - это адреса данных в блоках,
  т.е. дескрипторы/хэндлы блоков памяти.
А "внутри" ф-ций используются адреса самих блоков.
Каждая область может находиться в произвольном месте памяти. 
Куда её размещать - зависит от ОС.

Область памяти:
[размером в целое число страниц памяти]
[адрес первого байта кратен размеру страницы]
(состоит из блоков памяти без зазоров между ними)
===============
| Блок памяти |
|=============|
| Блок памяти |
|=============|
|     ...     |
===============

Блок памяти:
================================== \
| Size - размер данных / флаги   |  \
| Next - адрес след. блока       |   } служебная часть
| Prev - адрес предыдущего блока |  /
|--------------------------------| /
|                                |  <= дескриптор/хэндл блока памяти
| данные пользователя            |
|                                |
==================================

---------------------------------------------------------
|	Условие выравнивания\округления адресов (УВО): 	|
|	---------------------------------------------  	|
|	Адреса блоков выровнены по dword.              	|
|	Служебная часть кратна dword (4 байт).         	|
|	Данные кратны dword (4 байт).                  	|
---------------------------------------------------------

Size - размер в байтах для данных (!!!) в блоке {округлён до 4 байт минимум}
bit31 - флаг занятого блока.
Size должен быть меньше 2^31

Next - Адрес следующего блока {округлён до 4 байт}.
    если равен NULL : признак последнего блока кучи
в Next сохраняется адрес блока (адрес служебной области)
  а в параметрах функций передаются адреса данных в этих блоках
  (т.е. адрес блока + INFOSIZE)
  
Prev - адрес предыдущeго блока {округлён до 4 байт}.
    если равен NULL, то начальный блок

BLOCKISBUSY = 80 00 00 00h
;1000 0000 0000 0000_0000 0000 0000 0000b

условимся что BLOCKBRICK можно задавать равным 4, 8, 12, 16...(кратно 4)
Адрес_следующего_блока округляется до 4-х байт, поэтому
как минимум два младших бита свободны.
Младший бит (номер 0) - занятость блока памяти
Бит номер 1 - флаг последнего блока памяти в области памяти.
Если блок последний в области и адрес следующего блока равен нулю - 
то это самый последний блок в куче.


Создание кучи:
Создаётся (первичная в данном случае) область памяти размером SIZE0.
Хэндл кучи = адрес полученой памяти.

Создание области памяти:
У ОС запрашивается область памяти заданного размера.
Создаётся незанятый блок памяти в весь размер области.

Создание блока памяти:
Начиная с первичной области памяти (хэндл кучи в помощь)
находим незанятый блок памяти подходящего размера.
Меняем статус на занятый, корректируем размер
и если есть остаток в блоке памяти, то из него создаём новый незанятый.
Корректируем адреса следующих блоков.
У последнего в цепочке блока адрес следующего блока равен LASTBLOCK

Если BLOCKBRICK задавать равным INFOSIZE или меньше,
 то при создании новых блоков их размер данных будет кратен BLOCKBRICK.
 Например: если INFOSIZE = 8, то BLOCKBRICK = 4 или 8.
 Если BLOCKBRICK задаётся больше (16, 32..),
 то и INFOSIZE надо делать равным BLOCKBRICK.

Добавление новой области памяти происходит если
не нашёлся подходящий блок памяти при создании нового блока.
Размер области = размер блока округлённый до размера страницы,
но не меньше SIZESTEP

Удаление блока памяти:
Меняем статус на незанятый,
 если следующий блок не занятый и идет непосредственно после удаляемого,
 то объединить эти блоки.
Данные удалённого блока не обнуляются.

**********************************************
сделать проверку при создании новой области:
если новая область примыкает к последней старой области -
 - объединить их.

подумыть над заменой Size на (Next-this)
или замена Next на this+Size+INFOSIZE  ...