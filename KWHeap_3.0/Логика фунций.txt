
--------------------------------------------------
HHEAP CreateHeap (int size)
Создаёт кучу, возвращает хэндл кучи.
--------------------------------------------------

В куче для каждого блока в ОДНОЙ области соблюдается:
Следующий блок расположен сразу за данным,
 предыдущий блок расположен сразу перед данным.

Для первого/последнего в куче блока также 
 устанавливается флаг первого/последнего в области.

При size == 0 размер увеличивается до HEAPSIZE0.

--------------------------------------------------
MemAlloc size
-------------
size округлить до BLOCKBRICK (УВО).
проверяется на: (-BLOCKBRICK) > size > 0 ; -BLOCKBRICK=FFFF'FFFC, для BLOCKBRICK=4
  еггог, если условие не выполнено

Добавление области памяти {доделать !!!!!!!!!!!!}
 Размер новой области зависит от запрошенного размера блока [size].
 Его получаем округляя вверх до HEAPSIZESTEP параметр ( [size] + INFOSIZE )
 далее invoke CreateArea, размер_новой_области ; c проверкой на ошибку
 в старой области в последнем блоке:
  Next = адрес нового блока
  снять флаг последнего блока в куче
  установить флаг последнего блока в области
  не изменять Size, флаг первого блока в области,
             Prev, флаг первого блока в куче
 в новой области (один блок):
  Prev = адрес последнего блока в старой области
  установить флаг первого блока в области
  установить флаг последнего блока в области
  установить флаг последнего блока в куче

--------------------------------------------------
MemReAlloc addr, newsize
------------------------
newsize округлить до BLOCKBRICK (УВО).
проверяется на: (-BLOCKBRICK) > size > 0 ; -BLOCKBRICK=FFFF'FFFC, для BLOCKBRICK=4
  еггог, если условие не выполнено

А: размеры равны - выход.

Б: новый размер меньше старого:
---
Если следующий блок свободен и находится в той же области, то
 уменьшаем размер текущего блока (this.Size),
 увеличиваем размер следующего расширением влево
 (его начало сдвигаем в сторону меньших адресов)
 меняем this.Next, Next.Size (увеличивается).
Иначе если предыдущий блок свободен и находится в той же области, то
 сдвигаем начало текущего блока вправо и уменьшаем this.Size
 (начало блока сдвигаем в сторону больших адресов)
 меняем Prev.Next, Prev.Size (увеличивается).
Иначе (нет соседних свободных блоков)
 проверяем, вместится ли в зазор блок минимального размера.
 Если не вмещается, то оставляем без изменений и выходим.
 Если вмещается, то 
  уменьшаем 

   .................
(простое решение, реализовано)
newsize округлить до dword (УВО).
Если старый размер меньше нового (увеличиваем размер):
 Сделать новый блок с размером newblock.
 Скопировать туды байтики из прежней (addr).
 Очистить/освободить прежнюю ячейку.
Если старый размер больше нового (надо уменьшить размер):
 Если разница размеров меньше минимального размера блока, то выход.
 Иначе изменить размер блока, сделать ЗАНЯТЫЙ блок из остатка,
 не забыв изменить ссылки. ;) и удалить его,
 чтоб (возможно) объединить незанятые блоки.
Возвращается адрес нового блока
С флагами LASTxxx проблем нет, т.к. их копируем вместе с адресами.

(сложнее)
Если старый размер меньше нового (увеличиваем размер):
Если после блока есть свободное пространство достаточного размера - 
- расширить блок до newsize (если ещё остаётся место для нового блока),
иначе расширить на весь незанятый блок.
...

--------------------------------------------------
MemFree addr
------------
addr - адрес данных в блоке (клиентский)
Освобождаем блок. Объединяем его с соседними, если возможно, так:
Снимаем флаг занятости блока (BLOCKISBUSY).
Если текущий блок не последний в области, а значит и не последний в куче,
 а также не занят, то
 производим объединение текущего и следующего блоков.
Текущий блок может остаться неизменённым, а может объединиться со следующим.
Если блок не первый в области, а значит и не первый в куче,
 а также не занят, то
 производим объединение предыдущего и текущего блоков.
Можно вызвать процедуру для уже освобождённого блока. Не сломается. ))

---------------------------------
условная процедура объединения addr1 и addr2 (inline function ;)
---------------------------------
Процедура объединения двух свободных блоков.
Предполагается, что блоки находятся встык и в одной области (!!!),
 а также addr1 < addr2 и не заняты (!!!)
Адреса не должны быть равны NULL,
 должны быть валидными адресами блоков.
Size - размер блока, а не его данных

addr1.Size += addr2.Size
addr1.Next = addr2.Next
addr1.Prev без изменений
---------------------------------

факт: в KolibriOS вызов сис-функций сохраняет ebp.

размышлення:
Функция поиска свободного блока
использует хэндл блока, а не адрес блока или адрес кучи