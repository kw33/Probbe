Jullia.OBJ {первичная упрощённая версия}
----------
Имеется блок памяти, который состоит из массивов одинакового размера,
  содержат хэндлы: окна и контролов этого окна.
  
Для хранения битмапов используется
 системная пользовательская куча. (по 4К)


     Init
Загружает библиотеку lib_io.
Создаёт блок памяти для хэндлов окон и ЭУ. Controls - указатель на неё.


     CreateWindow
Создаётся окно. Используя сист.вызов.
Читается текст, описывающий элементы
 управления в этом окне и создаются эти ЭУ.



----------------------------------------
На каждый поток (окно) - кучу (Controls)
Обработчик DispatchMessage()
В данных определения элементов управления
Программное определение э.у. -
  - копирование данных э.у. в кучу,
  прибавить ссылку в массив э.у.

ЭУ может быть стандартным или комплексным.
Описание ЭУ
  - в памяти в байтовом виде
  - в текстовом файле

Комплексный
-----------
Описание содержит ссылки на другие ЭУ,
  которые тоже загружаются.

\\\\\\\\\\\\\\
Window - массив данных для окна
Controls - куча
Controls.Max ??
Controls.Count - функция ..?
Controls.List - массив ссылок на ЭУ
Controls.Sizes - массив размеров структур станд.ЭУ
Controls.Handlers - массив адресов обработчиков событий станд.ЭУ ??
   или
   Controls.Draw - массив адресов обработчиков событий Draw станд.ЭУ ??
   Controls.Key  - массив адресов обработчиков событий Key станд.ЭУ ??
   Controls.Mouse- массив адресов обработчиков событий Mouse станд.ЭУ ??
Controls.Last - ссылка на ЭУ, над которым был курсор в прошлый раз
 - 

struc tagMsg {
  .Sys dd ?
  .Sub dd ? ; подсобытие
  .Handle dd ?
  .X dd dw ? ; 
  .Y dd dw ?
  .Key dd ? ; клава или мышь
}
/////////////////////////////////////
GetMessage(Msg)
Получает событие для текущего потока
Системное или доп.
Сохраняет номер 
Для клавиатуры, мыши определяет хэндл ЭУ
Для мыши определяет координаты относительно ЭУ
  Преобразовывает клики в отдельные событ
Для клавы шорткаты для окна проверять
  и если не оно, то слать в ЭУ клавишу
  ..или отдельно..
  ShortCuts
Для мыши создавать доп номер подсобытия
Создавать события IN OUT при перемещении
  для ЭУ
----!!!
Создает (свою очередь для доп.событий)--
--отдельную ячейку с событием.


///////////\////\///\///\///\//\///\///\///\//\////\///\//\///\//
ф-ция диспетчер событий для ЭУ. ( для окна - отдельно ?? )
Dispatch (Msg или sysmsg) {
  --преобразование sysmsg...> msg
  mcall 37, ..   ; SF_MOUSE_GET
                   SSF_WINDOW_POSITION (1)
                   SSF_BUTTON (2)
                   SSF_BUTTON_EXT (3)
                   SSF_SET_CURSOR (5)
                   SSF_SCROLL_DATA (7)
  
  if (msg==MSG_MOVE) {
    foreach backward (ctrl in Controls) {
      if (CursorIsOverControl(ctrl) {
        SendMessage(msg,ctrl);
        // в SendMessage определяется обработчик (std/custom)
        return;
      }
    }
  }

  if (msg==MSG_CLICK) {
    foreach (ctrl in Controls) {


-----------------
В диспетчере сначала вызывается
  пользовательский обработчик события, 
  затем стандартный
  
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\ Events
   Мышъ
MSG_MOVE / X, Y
MSG_CLICK / No of button
MSG_SCROLL / dX, dY
MSG_HOVER / In/Out (доп)
   Клава
MSG_DOWN
MSG_UP
MSG_KEY (доп)
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\ msg
.Event dd ? ; MSG_...
.A dd ?
.B dd ?

\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
SendMessage(msg, ctrl)
если ctrl.Handler не NULL, то он вызывается.
иначе вызывается стд.обработчик по соотв-щему событию.


============================================== ЭУ
Type
X, Y, dX, dY
Prop
Handler

    
################################################################################
#######                            Принципы                              #######
################################################################################

Два варианта реализации:
1) GUI с окнами-контейнерами
2) GUI с окнами без контейнеризации

                                    GUI с окнами-контейнерами
                                    -------------------------
Каждое окно имеет дескриптор и структуру, в ней - свойства окна.
Дескриптор (хэндл) указывает на эту структуру.
Окно (если оно - контейнер) может содержать дочерние окна.
Все окна являются дочерними.
Особенность KolibriOS:
  Каждый поток имеет только одно окно (системное).
  Базовое, коренное окно привязывается к системному ...

Поток получает сообщение от системы.
Проводится предварительная обработка сообщения.
Вызывается обработчик сообщений (главного окна).
Управление возвращается системе.

Обработчик сообщений окна получает сообщение.
Проходит по списку его дочерних окон.
Для каждого вызывает его обработчик сообщений.
По возвращённому значению определяет, надо ли 
  самому обработать сообщение или оно уже обработано.
Управление возвращается.


                                    GUI с окнами без контейнеризации
                                    --------------------------------

